digraph y {
	edge [fontsize=10];
	node [shape=box,fontsize=10];
	orientation=landscape;
	rankdir=LR;
	/*
	margin=0.2;
	page="8.27,11.69"; // for A4 printing
	ratio=auto;
	*/

	q0 [label="0:\l  $accept -> . program $end\l  program -> . PROGRAM ID '{' stmts '}'\l"];
	q1 [label="1:\l  program -> PROGRAM . ID '{' stmts '}'\l"];
	q2 [label="2:\l  $accept -> program . $end\l"];
	q3 [label="3:\l  program -> PROGRAM ID . '{' stmts '}'\l"];
	q4 [label="4:\l  program -> PROGRAM ID '{' . stmts '}'\l  stmts -> . stmt\l  stmts -> . stmt stmts\l  type -> . PRIMITIVE\l  type -> . ARRAY LESS_THAN PRIMITIVE MORE_THAN\l  func_def -> . SUBPROGRAM ID '(' params ')' ':' type block\l  expression -> . ID\l  expression -> . literal\l  expression -> . func_call\l  expression -> . binary_expr\l  expression -> . access\l  expression -> . primitive_func\l  access -> . ID '[' expression ']'\l  literal -> . INTEGER\l  literal -> . DOUBLE\l  literal -> . CARACTERE\l  literal -> . STRING\l  literal -> . array_literal\l  array_literal -> . '{' literais '}'\l  func_call -> . ID '(' args ')'\l  primitive_func -> . ID '.' ID\l  binary_expr -> . expression binary_operator expression\l  stmt -> . ';'\l  stmt -> . func_def\l  stmt -> . expression ';'\l  stmt -> . if_stmt\l  stmt -> . for_stmt\l  stmt -> . return_stmt ';'\l  stmt -> . atrib ';'\l  stmt -> . declaration ';'\l  declaration -> . type atrib\l  declaration -> . type ID\l  atrib -> . ID '=' expression\l  atrib -> . ID INCREMENT\l  atrib -> . ID DECREMENT\l  if_stmt -> . IF '(' expression ')' block\l  if_stmt -> . IF '(' expression ')' block ELSE block\l  for_stmt -> . FOR '(' for_part ';' expression ';' for_part ')' block\l  return_stmt -> . RETURN expression\l"];
	q5 [label="5:\l  expression -> ID . { ';' OR AND MOD SPLIT TIMES POWER MINUS PLUS MORE_THAN_EQUALS LESS_THAN_EQUALS MORE_THAN LESS_THAN DIFFERENT COMPARISON }\l  access -> ID . '[' expression ']'\l  func_call -> ID . '(' args ')'\l  primitive_func -> ID . '.' ID\l  atrib -> ID . '=' expression\l  atrib -> ID . INCREMENT\l  atrib -> ID . DECREMENT\l"];
	q6 [label="6:\l  type -> PRIMITIVE . { '{' ID }\l"];
	q7 [label="7:\l  type -> ARRAY . LESS_THAN PRIMITIVE MORE_THAN\l"];
	q8 [label="8:\l  literal -> INTEGER . { ';' ']' ',' ')' '}' OR AND MOD SPLIT TIMES POWER MINUS PLUS MORE_THAN_EQUALS LESS_THAN_EQUALS MORE_THAN LESS_THAN DIFFERENT COMPARISON }\l"];
	q9 [label="9:\l  literal -> CARACTERE . { ';' ']' ',' ')' '}' OR AND MOD SPLIT TIMES POWER MINUS PLUS MORE_THAN_EQUALS LESS_THAN_EQUALS MORE_THAN LESS_THAN DIFFERENT COMPARISON }\l"];
	q10 [label="10:\l  literal -> DOUBLE . { ';' ']' ',' ')' '}' OR AND MOD SPLIT TIMES POWER MINUS PLUS MORE_THAN_EQUALS LESS_THAN_EQUALS MORE_THAN LESS_THAN DIFFERENT COMPARISON }\l"];
	q11 [label="11:\l  literal -> STRING . { ';' ']' ',' ')' '}' OR AND MOD SPLIT TIMES POWER MINUS PLUS MORE_THAN_EQUALS LESS_THAN_EQUALS MORE_THAN LESS_THAN DIFFERENT COMPARISON }\l"];
	q12 [label="12:\l  func_def -> SUBPROGRAM . ID '(' params ')' ':' type block\l"];
	q13 [label="13:\l  if_stmt -> IF . '(' expression ')' block\l  if_stmt -> IF . '(' expression ')' block ELSE block\l"];
	q14 [label="14:\l  for_stmt -> FOR . '(' for_part ';' expression ';' for_part ')' block\l"];
	q15 [label="15:\l  expression -> . ID\l  expression -> . literal\l  expression -> . func_call\l  expression -> . binary_expr\l  expression -> . access\l  expression -> . primitive_func\l  access -> . ID '[' expression ']'\l  literal -> . INTEGER\l  literal -> . DOUBLE\l  literal -> . CARACTERE\l  literal -> . STRING\l  literal -> . array_literal\l  array_literal -> . '{' literais '}'\l  func_call -> . ID '(' args ')'\l  primitive_func -> . ID '.' ID\l  binary_expr -> . expression binary_operator expression\l  return_stmt -> RETURN . expression\l"];
	q16 [label="16:\l  literal -> . INTEGER\l  literal -> . DOUBLE\l  literal -> . CARACTERE\l  literal -> . STRING\l  literal -> . array_literal\l  literais -> . literal\l  literais -> . literal ',' literais\l  array_literal -> . '{' literais '}'\l  array_literal -> '{' . literais '}'\l"];
	q17 [label="17:\l  stmt -> ';' . { ';' '}' '{' RETURN FOR IF SUBPROGRAM STRING DOUBLE CARACTERE INTEGER ARRAY PRIMITIVE ID }\l"];
	q18 [label="18:\l  program -> PROGRAM ID '{' stmts . '}'\l"];
	q19 [label="19:\l  stmts -> . stmt\l  stmts -> stmt . { '}' }\l  stmts -> . stmt stmts\l  stmts -> stmt . stmts\l  type -> . PRIMITIVE\l  type -> . ARRAY LESS_THAN PRIMITIVE MORE_THAN\l  func_def -> . SUBPROGRAM ID '(' params ')' ':' type block\l  expression -> . ID\l  expression -> . literal\l  expression -> . func_call\l  expression -> . binary_expr\l  expression -> . access\l  expression -> . primitive_func\l  access -> . ID '[' expression ']'\l  literal -> . INTEGER\l  literal -> . DOUBLE\l  literal -> . CARACTERE\l  literal -> . STRING\l  literal -> . array_literal\l  array_literal -> . '{' literais '}'\l  func_call -> . ID '(' args ')'\l  primitive_func -> . ID '.' ID\l  binary_expr -> . expression binary_operator expression\l  stmt -> . ';'\l  stmt -> . func_def\l  stmt -> . expression ';'\l  stmt -> . if_stmt\l  stmt -> . for_stmt\l  stmt -> . return_stmt ';'\l  stmt -> . atrib ';'\l  stmt -> . declaration ';'\l  declaration -> . type atrib\l  declaration -> . type ID\l  atrib -> . ID '=' expression\l  atrib -> . ID INCREMENT\l  atrib -> . ID DECREMENT\l  if_stmt -> . IF '(' expression ')' block\l  if_stmt -> . IF '(' expression ')' block ELSE block\l  for_stmt -> . FOR '(' for_part ';' expression ';' for_part ')' block\l  return_stmt -> . RETURN expression\l"];
	q20 [label="20:\l  declaration -> type . atrib\l  declaration -> type . ID\l  atrib -> . ID '=' expression\l  atrib -> . ID INCREMENT\l  atrib -> . ID DECREMENT\l"];
	q21 [label="21:\l  stmt -> func_def . { ';' '}' '{' RETURN FOR IF SUBPROGRAM STRING DOUBLE CARACTERE INTEGER ARRAY PRIMITIVE ID }\l"];
	q22 [label="22:\l  binary_expr -> expression . binary_operator expression\l  binary_operator -> . PLUS\l  binary_operator -> . MINUS\l  binary_operator -> . POWER\l  binary_operator -> . TIMES\l  binary_operator -> . SPLIT\l  binary_operator -> . MOD\l  binary_operator -> . COMPARISON\l  binary_operator -> . DIFFERENT\l  binary_operator -> . LESS_THAN\l  binary_operator -> . MORE_THAN\l  binary_operator -> . LESS_THAN_EQUALS\l  binary_operator -> . MORE_THAN_EQUALS\l  binary_operator -> . AND\l  binary_operator -> . OR\l  stmt -> expression . ';'\l"];
	q23 [label="23:\l  expression -> literal . { ';' ']' ',' ')' OR AND MOD SPLIT TIMES POWER MINUS PLUS MORE_THAN_EQUALS LESS_THAN_EQUALS MORE_THAN LESS_THAN DIFFERENT COMPARISON }\l"];
	q24 [label="24:\l  expression -> func_call . { ';' ']' ',' ')' OR AND MOD SPLIT TIMES POWER MINUS PLUS MORE_THAN_EQUALS LESS_THAN_EQUALS MORE_THAN LESS_THAN DIFFERENT COMPARISON }\l"];
	q25 [label="25:\l  expression -> binary_expr . { ';' ']' ',' ')' OR AND MOD SPLIT TIMES POWER MINUS PLUS MORE_THAN_EQUALS LESS_THAN_EQUALS MORE_THAN LESS_THAN DIFFERENT COMPARISON }\l"];
	q26 [label="26:\l  expression -> access . { ';' ']' ',' ')' OR AND MOD SPLIT TIMES POWER MINUS PLUS MORE_THAN_EQUALS LESS_THAN_EQUALS MORE_THAN LESS_THAN DIFFERENT COMPARISON }\l"];
	q27 [label="27:\l  expression -> primitive_func . { ';' ']' ',' ')' OR AND MOD SPLIT TIMES POWER MINUS PLUS MORE_THAN_EQUALS LESS_THAN_EQUALS MORE_THAN LESS_THAN DIFFERENT COMPARISON }\l"];
	q28 [label="28:\l  literal -> array_literal . { ';' ']' ',' ')' '}' OR AND MOD SPLIT TIMES POWER MINUS PLUS MORE_THAN_EQUALS LESS_THAN_EQUALS MORE_THAN LESS_THAN DIFFERENT COMPARISON }\l"];
	q29 [label="29:\l  stmt -> if_stmt . { ';' '}' '{' RETURN FOR IF SUBPROGRAM STRING DOUBLE CARACTERE INTEGER ARRAY PRIMITIVE ID }\l"];
	q30 [label="30:\l  stmt -> for_stmt . { ';' '}' '{' RETURN FOR IF SUBPROGRAM STRING DOUBLE CARACTERE INTEGER ARRAY PRIMITIVE ID }\l"];
	q31 [label="31:\l  stmt -> return_stmt . ';'\l"];
	q32 [label="32:\l  stmt -> atrib . ';'\l"];
	q33 [label="33:\l  stmt -> declaration . ';'\l"];
	q34 [label="34:\l  atrib -> ID INCREMENT . { ';' ')' }\l"];
	q35 [label="35:\l  atrib -> ID DECREMENT . { ';' ')' }\l"];
	q36 [label="36:\l  expression -> . ID\l  expression -> . literal\l  expression -> . func_call\l  expression -> . binary_expr\l  expression -> . access\l  expression -> . primitive_func\l  access -> . ID '[' expression ']'\l  literal -> . INTEGER\l  literal -> . DOUBLE\l  literal -> . CARACTERE\l  literal -> . STRING\l  literal -> . array_literal\l  array_literal -> . '{' literais '}'\l  func_call -> . ID '(' args ')'\l  func_call -> ID '(' . args ')'\l  primitive_func -> . ID '.' ID\l  args -> . expressions\l  expressions -> . expression\l  expressions -> . expression ',' expressions\l  binary_expr -> . expression binary_operator expression\l"];
	q37 [label="37:\l  expression -> . ID\l  expression -> . literal\l  expression -> . func_call\l  expression -> . binary_expr\l  expression -> . access\l  expression -> . primitive_func\l  access -> . ID '[' expression ']'\l  access -> ID '[' . expression ']'\l  literal -> . INTEGER\l  literal -> . DOUBLE\l  literal -> . CARACTERE\l  literal -> . STRING\l  literal -> . array_literal\l  array_literal -> . '{' literais '}'\l  func_call -> . ID '(' args ')'\l  primitive_func -> . ID '.' ID\l  binary_expr -> . expression binary_operator expression\l"];
	q38 [label="38:\l  primitive_func -> ID '.' . ID\l"];
	q39 [label="39:\l  expression -> . ID\l  expression -> . literal\l  expression -> . func_call\l  expression -> . binary_expr\l  expression -> . access\l  expression -> . primitive_func\l  access -> . ID '[' expression ']'\l  literal -> . INTEGER\l  literal -> . DOUBLE\l  literal -> . CARACTERE\l  literal -> . STRING\l  literal -> . array_literal\l  array_literal -> . '{' literais '}'\l  func_call -> . ID '(' args ')'\l  primitive_func -> . ID '.' ID\l  binary_expr -> . expression binary_operator expression\l  atrib -> ID '=' . expression\l"];
	q40 [label="40:\l  type -> ARRAY LESS_THAN . PRIMITIVE MORE_THAN\l"];
	q41 [label="41:\l  func_def -> SUBPROGRAM ID . '(' params ')' ':' type block\l"];
	q42 [label="42:\l  expression -> . ID\l  expression -> . literal\l  expression -> . func_call\l  expression -> . binary_expr\l  expression -> . access\l  expression -> . primitive_func\l  access -> . ID '[' expression ']'\l  literal -> . INTEGER\l  literal -> . DOUBLE\l  literal -> . CARACTERE\l  literal -> . STRING\l  literal -> . array_literal\l  array_literal -> . '{' literais '}'\l  func_call -> . ID '(' args ')'\l  primitive_func -> . ID '.' ID\l  binary_expr -> . expression binary_operator expression\l  if_stmt -> IF '(' . expression ')' block\l  if_stmt -> IF '(' . expression ')' block ELSE block\l"];
	q43 [label="43:\l  type -> . PRIMITIVE\l  type -> . ARRAY LESS_THAN PRIMITIVE MORE_THAN\l  declaration -> . type atrib\l  declaration -> . type ID\l  atrib -> . ID '=' expression\l  atrib -> . ID INCREMENT\l  atrib -> . ID DECREMENT\l  for_stmt -> FOR '(' . for_part ';' expression ';' for_part ')' block\l  for_part -> . atrib\l  for_part -> . declaration\l"];
	q44 [label="44:\l  expression -> ID . { ';' ']' ',' ')' OR AND MOD SPLIT TIMES POWER MINUS PLUS MORE_THAN_EQUALS LESS_THAN_EQUALS MORE_THAN LESS_THAN DIFFERENT COMPARISON }\l  access -> ID . '[' expression ']'\l  func_call -> ID . '(' args ')'\l  primitive_func -> ID . '.' ID\l"];
	q45 [label="45:\l  binary_expr -> expression . binary_operator expression\l  binary_operator -> . PLUS\l  binary_operator -> . MINUS\l  binary_operator -> . POWER\l  binary_operator -> . TIMES\l  binary_operator -> . SPLIT\l  binary_operator -> . MOD\l  binary_operator -> . COMPARISON\l  binary_operator -> . DIFFERENT\l  binary_operator -> . LESS_THAN\l  binary_operator -> . MORE_THAN\l  binary_operator -> . LESS_THAN_EQUALS\l  binary_operator -> . MORE_THAN_EQUALS\l  binary_operator -> . AND\l  binary_operator -> . OR\l  return_stmt -> RETURN expression . { ';' }\l"];
	q46 [label="46:\l  literais -> literal . { '}' }\l  literais -> literal . ',' literais\l"];
	q47 [label="47:\l  array_literal -> '{' literais . '}'\l"];
	q48 [label="48:\l  program -> PROGRAM ID '{' stmts '}' . { $end }\l"];
	q49 [label="49:\l  stmts -> stmt stmts . { '}' }\l"];
	q50 [label="50:\l  declaration -> type ID . { ';' ')' }\l  atrib -> ID . '=' expression\l  atrib -> ID . INCREMENT\l  atrib -> ID . DECREMENT\l"];
	q51 [label="51:\l  declaration -> type atrib . { ';' ')' }\l"];
	q52 [label="52:\l  binary_operator -> COMPARISON . { '{' STRING DOUBLE CARACTERE INTEGER ID }\l"];
	q53 [label="53:\l  binary_operator -> DIFFERENT . { '{' STRING DOUBLE CARACTERE INTEGER ID }\l"];
	q54 [label="54:\l  binary_operator -> LESS_THAN . { '{' STRING DOUBLE CARACTERE INTEGER ID }\l"];
	q55 [label="55:\l  binary_operator -> MORE_THAN . { '{' STRING DOUBLE CARACTERE INTEGER ID }\l"];
	q56 [label="56:\l  binary_operator -> LESS_THAN_EQUALS . { '{' STRING DOUBLE CARACTERE INTEGER ID }\l"];
	q57 [label="57:\l  binary_operator -> MORE_THAN_EQUALS . { '{' STRING DOUBLE CARACTERE INTEGER ID }\l"];
	q58 [label="58:\l  binary_operator -> PLUS . { '{' STRING DOUBLE CARACTERE INTEGER ID }\l"];
	q59 [label="59:\l  binary_operator -> MINUS . { '{' STRING DOUBLE CARACTERE INTEGER ID }\l"];
	q60 [label="60:\l  binary_operator -> POWER . { '{' STRING DOUBLE CARACTERE INTEGER ID }\l"];
	q61 [label="61:\l  binary_operator -> TIMES . { '{' STRING DOUBLE CARACTERE INTEGER ID }\l"];
	q62 [label="62:\l  binary_operator -> SPLIT . { '{' STRING DOUBLE CARACTERE INTEGER ID }\l"];
	q63 [label="63:\l  binary_operator -> MOD . { '{' STRING DOUBLE CARACTERE INTEGER ID }\l"];
	q64 [label="64:\l  binary_operator -> AND . { '{' STRING DOUBLE CARACTERE INTEGER ID }\l"];
	q65 [label="65:\l  binary_operator -> OR . { '{' STRING DOUBLE CARACTERE INTEGER ID }\l"];
	q66 [label="66:\l  stmt -> expression ';' . { ';' '}' '{' RETURN FOR IF SUBPROGRAM STRING DOUBLE CARACTERE INTEGER ARRAY PRIMITIVE ID }\l"];
	q67 [label="67:\l  expression -> . ID\l  expression -> . literal\l  expression -> . func_call\l  expression -> . binary_expr\l  expression -> . access\l  expression -> . primitive_func\l  access -> . ID '[' expression ']'\l  literal -> . INTEGER\l  literal -> . DOUBLE\l  literal -> . CARACTERE\l  literal -> . STRING\l  literal -> . array_literal\l  array_literal -> . '{' literais '}'\l  func_call -> . ID '(' args ')'\l  primitive_func -> . ID '.' ID\l  binary_expr -> . expression binary_operator expression\l  binary_expr -> expression binary_operator . expression\l"];
	q68 [label="68:\l  stmt -> return_stmt ';' . { ';' '}' '{' RETURN FOR IF SUBPROGRAM STRING DOUBLE CARACTERE INTEGER ARRAY PRIMITIVE ID }\l"];
	q69 [label="69:\l  stmt -> atrib ';' . { ';' '}' '{' RETURN FOR IF SUBPROGRAM STRING DOUBLE CARACTERE INTEGER ARRAY PRIMITIVE ID }\l"];
	q70 [label="70:\l  stmt -> declaration ';' . { ';' '}' '{' RETURN FOR IF SUBPROGRAM STRING DOUBLE CARACTERE INTEGER ARRAY PRIMITIVE ID }\l"];
	q71 [label="71:\l  expressions -> expression . { ')' }\l  expressions -> expression . ',' expressions\l  binary_expr -> expression . binary_operator expression\l  binary_operator -> . PLUS\l  binary_operator -> . MINUS\l  binary_operator -> . POWER\l  binary_operator -> . TIMES\l  binary_operator -> . SPLIT\l  binary_operator -> . MOD\l  binary_operator -> . COMPARISON\l  binary_operator -> . DIFFERENT\l  binary_operator -> . LESS_THAN\l  binary_operator -> . MORE_THAN\l  binary_operator -> . LESS_THAN_EQUALS\l  binary_operator -> . MORE_THAN_EQUALS\l  binary_operator -> . AND\l  binary_operator -> . OR\l"];
	q72 [label="72:\l  func_call -> ID '(' args . ')'\l"];
	q73 [label="73:\l  args -> expressions . { ')' }\l"];
	q74 [label="74:\l  access -> ID '[' expression . ']'\l  binary_expr -> expression . binary_operator expression\l  binary_operator -> . PLUS\l  binary_operator -> . MINUS\l  binary_operator -> . POWER\l  binary_operator -> . TIMES\l  binary_operator -> . SPLIT\l  binary_operator -> . MOD\l  binary_operator -> . COMPARISON\l  binary_operator -> . DIFFERENT\l  binary_operator -> . LESS_THAN\l  binary_operator -> . MORE_THAN\l  binary_operator -> . LESS_THAN_EQUALS\l  binary_operator -> . MORE_THAN_EQUALS\l  binary_operator -> . AND\l  binary_operator -> . OR\l"];
	q75 [label="75:\l  primitive_func -> ID '.' ID . { ';' ']' ',' ')' OR AND MOD SPLIT TIMES POWER MINUS PLUS MORE_THAN_EQUALS LESS_THAN_EQUALS MORE_THAN LESS_THAN DIFFERENT COMPARISON }\l"];
	q76 [label="76:\l  binary_expr -> expression . binary_operator expression\l  binary_operator -> . PLUS\l  binary_operator -> . MINUS\l  binary_operator -> . POWER\l  binary_operator -> . TIMES\l  binary_operator -> . SPLIT\l  binary_operator -> . MOD\l  binary_operator -> . COMPARISON\l  binary_operator -> . DIFFERENT\l  binary_operator -> . LESS_THAN\l  binary_operator -> . MORE_THAN\l  binary_operator -> . LESS_THAN_EQUALS\l  binary_operator -> . MORE_THAN_EQUALS\l  binary_operator -> . AND\l  binary_operator -> . OR\l  atrib -> ID '=' expression . { ';' ')' }\l"];
	q77 [label="77:\l  type -> ARRAY LESS_THAN PRIMITIVE . MORE_THAN\l"];
	q78 [label="78:\l  type -> . PRIMITIVE\l  type -> . ARRAY LESS_THAN PRIMITIVE MORE_THAN\l  func_def -> SUBPROGRAM ID '(' . params ')' ':' type block\l  params -> . param\l  params -> . param ',' params\l  params -> . { ')' }\l  param -> . type ID\l"];
	q79 [label="79:\l  binary_expr -> expression . binary_operator expression\l  binary_operator -> . PLUS\l  binary_operator -> . MINUS\l  binary_operator -> . POWER\l  binary_operator -> . TIMES\l  binary_operator -> . SPLIT\l  binary_operator -> . MOD\l  binary_operator -> . COMPARISON\l  binary_operator -> . DIFFERENT\l  binary_operator -> . LESS_THAN\l  binary_operator -> . MORE_THAN\l  binary_operator -> . LESS_THAN_EQUALS\l  binary_operator -> . MORE_THAN_EQUALS\l  binary_operator -> . AND\l  binary_operator -> . OR\l  if_stmt -> IF '(' expression . ')' block\l  if_stmt -> IF '(' expression . ')' block ELSE block\l"];
	q80 [label="80:\l  atrib -> ID . '=' expression\l  atrib -> ID . INCREMENT\l  atrib -> ID . DECREMENT\l"];
	q81 [label="81:\l  for_part -> atrib . { ';' ')' }\l"];
	q82 [label="82:\l  for_part -> declaration . { ';' ')' }\l"];
	q83 [label="83:\l  for_stmt -> FOR '(' for_part . ';' expression ';' for_part ')' block\l"];
	q84 [label="84:\l  literal -> . INTEGER\l  literal -> . DOUBLE\l  literal -> . CARACTERE\l  literal -> . STRING\l  literal -> . array_literal\l  literais -> . literal\l  literais -> . literal ',' literais\l  literais -> literal ',' . literais\l  array_literal -> . '{' literais '}'\l"];
	q85 [label="85:\l  array_literal -> '{' literais '}' . { ';' ']' ',' ')' '}' OR AND MOD SPLIT TIMES POWER MINUS PLUS MORE_THAN_EQUALS LESS_THAN_EQUALS MORE_THAN LESS_THAN DIFFERENT COMPARISON }\l"];
	q86 [label="86:\l  binary_expr -> expression . binary_operator expression\l  binary_expr -> expression binary_operator expression . { ';' ']' ',' ')' OR AND MOD SPLIT TIMES POWER MINUS PLUS MORE_THAN_EQUALS LESS_THAN_EQUALS MORE_THAN LESS_THAN DIFFERENT COMPARISON }\l  binary_operator -> . PLUS\l  binary_operator -> . MINUS\l  binary_operator -> . POWER\l  binary_operator -> . TIMES\l  binary_operator -> . SPLIT\l  binary_operator -> . MOD\l  binary_operator -> . COMPARISON\l  binary_operator -> . DIFFERENT\l  binary_operator -> . LESS_THAN\l  binary_operator -> . MORE_THAN\l  binary_operator -> . LESS_THAN_EQUALS\l  binary_operator -> . MORE_THAN_EQUALS\l  binary_operator -> . AND\l  binary_operator -> . OR\l"];
	q87 [label="87:\l  expression -> . ID\l  expression -> . literal\l  expression -> . func_call\l  expression -> . binary_expr\l  expression -> . access\l  expression -> . primitive_func\l  access -> . ID '[' expression ']'\l  literal -> . INTEGER\l  literal -> . DOUBLE\l  literal -> . CARACTERE\l  literal -> . STRING\l  literal -> . array_literal\l  array_literal -> . '{' literais '}'\l  func_call -> . ID '(' args ')'\l  primitive_func -> . ID '.' ID\l  expressions -> . expression\l  expressions -> . expression ',' expressions\l  expressions -> expression ',' . expressions\l  binary_expr -> . expression binary_operator expression\l"];
	q88 [label="88:\l  func_call -> ID '(' args ')' . { ';' ']' ',' ')' OR AND MOD SPLIT TIMES POWER MINUS PLUS MORE_THAN_EQUALS LESS_THAN_EQUALS MORE_THAN LESS_THAN DIFFERENT COMPARISON }\l"];
	q89 [label="89:\l  access -> ID '[' expression ']' . { ';' ']' ',' ')' OR AND MOD SPLIT TIMES POWER MINUS PLUS MORE_THAN_EQUALS LESS_THAN_EQUALS MORE_THAN LESS_THAN DIFFERENT COMPARISON }\l"];
	q90 [label="90:\l  type -> ARRAY LESS_THAN PRIMITIVE MORE_THAN . { '{' ID }\l"];
	q91 [label="91:\l  param -> type . ID\l"];
	q92 [label="92:\l  func_def -> SUBPROGRAM ID '(' params . ')' ':' type block\l"];
	q93 [label="93:\l  params -> param . { ')' }\l  params -> param . ',' params\l"];
	q94 [label="94:\l  block -> . '{' stmts '}'\l  if_stmt -> IF '(' expression ')' . block\l  if_stmt -> IF '(' expression ')' . block ELSE block\l"];
	q95 [label="95:\l  expression -> . ID\l  expression -> . literal\l  expression -> . func_call\l  expression -> . binary_expr\l  expression -> . access\l  expression -> . primitive_func\l  access -> . ID '[' expression ']'\l  literal -> . INTEGER\l  literal -> . DOUBLE\l  literal -> . CARACTERE\l  literal -> . STRING\l  literal -> . array_literal\l  array_literal -> . '{' literais '}'\l  func_call -> . ID '(' args ')'\l  primitive_func -> . ID '.' ID\l  binary_expr -> . expression binary_operator expression\l  for_stmt -> FOR '(' for_part ';' . expression ';' for_part ')' block\l"];
	q96 [label="96:\l  literais -> literal ',' literais . { '}' }\l"];
	q97 [label="97:\l  expressions -> expression ',' expressions . { ')' }\l"];
	q98 [label="98:\l  param -> type ID . { ',' ')' }\l"];
	q99 [label="99:\l  func_def -> SUBPROGRAM ID '(' params ')' . ':' type block\l"];
	q100 [label="100:\l  type -> . PRIMITIVE\l  type -> . ARRAY LESS_THAN PRIMITIVE MORE_THAN\l  params -> . param\l  params -> . param ',' params\l  params -> param ',' . params\l  params -> . { ')' }\l  param -> . type ID\l"];
	q101 [label="101:\l  stmts -> . stmt\l  stmts -> . stmt stmts\l  type -> . PRIMITIVE\l  type -> . ARRAY LESS_THAN PRIMITIVE MORE_THAN\l  func_def -> . SUBPROGRAM ID '(' params ')' ':' type block\l  block -> '{' . stmts '}'\l  expression -> . ID\l  expression -> . literal\l  expression -> . func_call\l  expression -> . binary_expr\l  expression -> . access\l  expression -> . primitive_func\l  access -> . ID '[' expression ']'\l  literal -> . INTEGER\l  literal -> . DOUBLE\l  literal -> . CARACTERE\l  literal -> . STRING\l  literal -> . array_literal\l  array_literal -> . '{' literais '}'\l  func_call -> . ID '(' args ')'\l  primitive_func -> . ID '.' ID\l  binary_expr -> . expression binary_operator expression\l  stmt -> . ';'\l  stmt -> . func_def\l  stmt -> . expression ';'\l  stmt -> . if_stmt\l  stmt -> . for_stmt\l  stmt -> . return_stmt ';'\l  stmt -> . atrib ';'\l  stmt -> . declaration ';'\l  declaration -> . type atrib\l  declaration -> . type ID\l  atrib -> . ID '=' expression\l  atrib -> . ID INCREMENT\l  atrib -> . ID DECREMENT\l  if_stmt -> . IF '(' expression ')' block\l  if_stmt -> . IF '(' expression ')' block ELSE block\l  for_stmt -> . FOR '(' for_part ';' expression ';' for_part ')' block\l  return_stmt -> . RETURN expression\l"];
	q102 [label="102:\l  if_stmt -> IF '(' expression ')' block . { ';' '}' '{' RETURN FOR IF SUBPROGRAM STRING DOUBLE CARACTERE INTEGER ARRAY PRIMITIVE ID }\l  if_stmt -> IF '(' expression ')' block . ELSE block\l"];
	q103 [label="103:\l  binary_expr -> expression . binary_operator expression\l  binary_operator -> . PLUS\l  binary_operator -> . MINUS\l  binary_operator -> . POWER\l  binary_operator -> . TIMES\l  binary_operator -> . SPLIT\l  binary_operator -> . MOD\l  binary_operator -> . COMPARISON\l  binary_operator -> . DIFFERENT\l  binary_operator -> . LESS_THAN\l  binary_operator -> . MORE_THAN\l  binary_operator -> . LESS_THAN_EQUALS\l  binary_operator -> . MORE_THAN_EQUALS\l  binary_operator -> . AND\l  binary_operator -> . OR\l  for_stmt -> FOR '(' for_part ';' expression . ';' for_part ')' block\l"];
	q104 [label="104:\l  type -> . PRIMITIVE\l  type -> . ARRAY LESS_THAN PRIMITIVE MORE_THAN\l  func_def -> SUBPROGRAM ID '(' params ')' ':' . type block\l"];
	q105 [label="105:\l  params -> param ',' params . { ')' }\l"];
	q106 [label="106:\l  block -> '{' stmts . '}'\l"];
	q107 [label="107:\l  block -> . '{' stmts '}'\l  if_stmt -> IF '(' expression ')' block ELSE . block\l"];
	q108 [label="108:\l  type -> . PRIMITIVE\l  type -> . ARRAY LESS_THAN PRIMITIVE MORE_THAN\l  declaration -> . type atrib\l  declaration -> . type ID\l  atrib -> . ID '=' expression\l  atrib -> . ID INCREMENT\l  atrib -> . ID DECREMENT\l  for_stmt -> FOR '(' for_part ';' expression ';' . for_part ')' block\l  for_part -> . atrib\l  for_part -> . declaration\l"];
	q109 [label="109:\l  func_def -> SUBPROGRAM ID '(' params ')' ':' type . block\l  block -> . '{' stmts '}'\l"];
	q110 [label="110:\l  block -> '{' stmts '}' . { ';' '}' '{' RETURN FOR ELSE IF SUBPROGRAM STRING DOUBLE CARACTERE INTEGER ARRAY PRIMITIVE ID }\l"];
	q111 [label="111:\l  if_stmt -> IF '(' expression ')' block ELSE block . { ';' '}' '{' RETURN FOR IF SUBPROGRAM STRING DOUBLE CARACTERE INTEGER ARRAY PRIMITIVE ID }\l"];
	q112 [label="112:\l  for_stmt -> FOR '(' for_part ';' expression ';' for_part . ')' block\l"];
	q113 [label="113:\l  func_def -> SUBPROGRAM ID '(' params ')' ':' type block . { ';' '}' '{' RETURN FOR IF SUBPROGRAM STRING DOUBLE CARACTERE INTEGER ARRAY PRIMITIVE ID }\l"];
	q114 [label="114:\l  block -> . '{' stmts '}'\l  for_stmt -> FOR '(' for_part ';' expression ';' for_part ')' . block\l"];
	q115 [label="115:\l  for_stmt -> FOR '(' for_part ';' expression ';' for_part ')' block . { ';' '}' '{' RETURN FOR IF SUBPROGRAM STRING DOUBLE CARACTERE INTEGER ARRAY PRIMITIVE ID }\l"];

	q0 -> q1 [label="PROGRAM"];
	q0 -> q2 [label="program"];
	q1 -> q3 [label="ID"];
	q3 -> q4 [label="'{'"];
	q4 -> q5 [label="ID"];
	q4 -> q6 [label="PRIMITIVE"];
	q4 -> q7 [label="ARRAY"];
	q4 -> q8 [label="INTEGER"];
	q4 -> q9 [label="CARACTERE"];
	q4 -> q10 [label="DOUBLE"];
	q4 -> q11 [label="STRING"];
	q4 -> q12 [label="SUBPROGRAM"];
	q4 -> q13 [label="IF"];
	q4 -> q14 [label="FOR"];
	q4 -> q15 [label="RETURN"];
	q4 -> q16 [label="'{'"];
	q4 -> q17 [label="';'"];
	q4 -> q18 [label="stmts"];
	q4 -> q19 [label="stmt"];
	q4 -> q20 [label="type"];
	q4 -> q21 [label="func_def"];
	q4 -> q22 [label="expression"];
	q4 -> q23 [label="literal"];
	q4 -> q24 [label="func_call"];
	q4 -> q25 [label="binary_expr"];
	q4 -> q26 [label="access"];
	q4 -> q27 [label="primitive_func"];
	q4 -> q28 [label="array_literal"];
	q4 -> q29 [label="if_stmt"];
	q4 -> q30 [label="for_stmt"];
	q4 -> q31 [label="return_stmt"];
	q4 -> q32 [label="atrib"];
	q4 -> q33 [label="declaration"];
	q5 -> q34 [label="INCREMENT"];
	q5 -> q35 [label="DECREMENT"];
	q5 -> q36 [label="'('"];
	q5 -> q37 [label="'['"];
	q5 -> q38 [label="'.'"];
	q5 -> q39 [label="'='"];
	q7 -> q40 [label="LESS_THAN"];
	q12 -> q41 [label="ID"];
	q13 -> q42 [label="'('"];
	q14 -> q43 [label="'('"];
	q15 -> q44 [label="ID"];
	q15 -> q8 [label="INTEGER"];
	q15 -> q9 [label="CARACTERE"];
	q15 -> q10 [label="DOUBLE"];
	q15 -> q11 [label="STRING"];
	q15 -> q16 [label="'{'"];
	q15 -> q45 [label="expression"];
	q15 -> q23 [label="literal"];
	q15 -> q24 [label="func_call"];
	q15 -> q25 [label="binary_expr"];
	q15 -> q26 [label="access"];
	q15 -> q27 [label="primitive_func"];
	q15 -> q28 [label="array_literal"];
	q16 -> q8 [label="INTEGER"];
	q16 -> q9 [label="CARACTERE"];
	q16 -> q10 [label="DOUBLE"];
	q16 -> q11 [label="STRING"];
	q16 -> q16 [label="'{'"];
	q16 -> q46 [label="literal"];
	q16 -> q28 [label="array_literal"];
	q16 -> q47 [label="literais"];
	q18 -> q48 [label="'}'"];
	q19 -> q5 [label="ID"];
	q19 -> q6 [label="PRIMITIVE"];
	q19 -> q7 [label="ARRAY"];
	q19 -> q8 [label="INTEGER"];
	q19 -> q9 [label="CARACTERE"];
	q19 -> q10 [label="DOUBLE"];
	q19 -> q11 [label="STRING"];
	q19 -> q12 [label="SUBPROGRAM"];
	q19 -> q13 [label="IF"];
	q19 -> q14 [label="FOR"];
	q19 -> q15 [label="RETURN"];
	q19 -> q16 [label="'{'"];
	q19 -> q17 [label="';'"];
	q19 -> q49 [label="stmts"];
	q19 -> q19 [label="stmt"];
	q19 -> q20 [label="type"];
	q19 -> q21 [label="func_def"];
	q19 -> q22 [label="expression"];
	q19 -> q23 [label="literal"];
	q19 -> q24 [label="func_call"];
	q19 -> q25 [label="binary_expr"];
	q19 -> q26 [label="access"];
	q19 -> q27 [label="primitive_func"];
	q19 -> q28 [label="array_literal"];
	q19 -> q29 [label="if_stmt"];
	q19 -> q30 [label="for_stmt"];
	q19 -> q31 [label="return_stmt"];
	q19 -> q32 [label="atrib"];
	q19 -> q33 [label="declaration"];
	q20 -> q50 [label="ID"];
	q20 -> q51 [label="atrib"];
	q22 -> q52 [label="COMPARISON"];
	q22 -> q53 [label="DIFFERENT"];
	q22 -> q54 [label="LESS_THAN"];
	q22 -> q55 [label="MORE_THAN"];
	q22 -> q56 [label="LESS_THAN_EQUALS"];
	q22 -> q57 [label="MORE_THAN_EQUALS"];
	q22 -> q58 [label="PLUS"];
	q22 -> q59 [label="MINUS"];
	q22 -> q60 [label="POWER"];
	q22 -> q61 [label="TIMES"];
	q22 -> q62 [label="SPLIT"];
	q22 -> q63 [label="MOD"];
	q22 -> q64 [label="AND"];
	q22 -> q65 [label="OR"];
	q22 -> q66 [label="';'"];
	q22 -> q67 [label="binary_operator"];
	q31 -> q68 [label="';'"];
	q32 -> q69 [label="';'"];
	q33 -> q70 [label="';'"];
	q36 -> q44 [label="ID"];
	q36 -> q8 [label="INTEGER"];
	q36 -> q9 [label="CARACTERE"];
	q36 -> q10 [label="DOUBLE"];
	q36 -> q11 [label="STRING"];
	q36 -> q16 [label="'{'"];
	q36 -> q71 [label="expression"];
	q36 -> q23 [label="literal"];
	q36 -> q24 [label="func_call"];
	q36 -> q25 [label="binary_expr"];
	q36 -> q26 [label="access"];
	q36 -> q27 [label="primitive_func"];
	q36 -> q28 [label="array_literal"];
	q36 -> q72 [label="args"];
	q36 -> q73 [label="expressions"];
	q37 -> q44 [label="ID"];
	q37 -> q8 [label="INTEGER"];
	q37 -> q9 [label="CARACTERE"];
	q37 -> q10 [label="DOUBLE"];
	q37 -> q11 [label="STRING"];
	q37 -> q16 [label="'{'"];
	q37 -> q74 [label="expression"];
	q37 -> q23 [label="literal"];
	q37 -> q24 [label="func_call"];
	q37 -> q25 [label="binary_expr"];
	q37 -> q26 [label="access"];
	q37 -> q27 [label="primitive_func"];
	q37 -> q28 [label="array_literal"];
	q38 -> q75 [label="ID"];
	q39 -> q44 [label="ID"];
	q39 -> q8 [label="INTEGER"];
	q39 -> q9 [label="CARACTERE"];
	q39 -> q10 [label="DOUBLE"];
	q39 -> q11 [label="STRING"];
	q39 -> q16 [label="'{'"];
	q39 -> q76 [label="expression"];
	q39 -> q23 [label="literal"];
	q39 -> q24 [label="func_call"];
	q39 -> q25 [label="binary_expr"];
	q39 -> q26 [label="access"];
	q39 -> q27 [label="primitive_func"];
	q39 -> q28 [label="array_literal"];
	q40 -> q77 [label="PRIMITIVE"];
	q41 -> q78 [label="'('"];
	q42 -> q44 [label="ID"];
	q42 -> q8 [label="INTEGER"];
	q42 -> q9 [label="CARACTERE"];
	q42 -> q10 [label="DOUBLE"];
	q42 -> q11 [label="STRING"];
	q42 -> q16 [label="'{'"];
	q42 -> q79 [label="expression"];
	q42 -> q23 [label="literal"];
	q42 -> q24 [label="func_call"];
	q42 -> q25 [label="binary_expr"];
	q42 -> q26 [label="access"];
	q42 -> q27 [label="primitive_func"];
	q42 -> q28 [label="array_literal"];
	q43 -> q80 [label="ID"];
	q43 -> q6 [label="PRIMITIVE"];
	q43 -> q7 [label="ARRAY"];
	q43 -> q20 [label="type"];
	q43 -> q81 [label="atrib"];
	q43 -> q82 [label="declaration"];
	q43 -> q83 [label="for_part"];
	q44 -> q36 [label="'('"];
	q44 -> q37 [label="'['"];
	q44 -> q38 [label="'.'"];
	q45 -> q52 [label="COMPARISON"];
	q45 -> q53 [label="DIFFERENT"];
	q45 -> q54 [label="LESS_THAN"];
	q45 -> q55 [label="MORE_THAN"];
	q45 -> q56 [label="LESS_THAN_EQUALS"];
	q45 -> q57 [label="MORE_THAN_EQUALS"];
	q45 -> q58 [label="PLUS"];
	q45 -> q59 [label="MINUS"];
	q45 -> q60 [label="POWER"];
	q45 -> q61 [label="TIMES"];
	q45 -> q62 [label="SPLIT"];
	q45 -> q63 [label="MOD"];
	q45 -> q64 [label="AND"];
	q45 -> q65 [label="OR"];
	q45 -> q67 [label="binary_operator"];
	q46 -> q84 [label="','"];
	q47 -> q85 [label="'}'"];
	q50 -> q34 [label="INCREMENT"];
	q50 -> q35 [label="DECREMENT"];
	q50 -> q39 [label="'='"];
	q67 -> q44 [label="ID"];
	q67 -> q8 [label="INTEGER"];
	q67 -> q9 [label="CARACTERE"];
	q67 -> q10 [label="DOUBLE"];
	q67 -> q11 [label="STRING"];
	q67 -> q16 [label="'{'"];
	q67 -> q86 [label="expression"];
	q67 -> q23 [label="literal"];
	q67 -> q24 [label="func_call"];
	q67 -> q25 [label="binary_expr"];
	q67 -> q26 [label="access"];
	q67 -> q27 [label="primitive_func"];
	q67 -> q28 [label="array_literal"];
	q71 -> q52 [label="COMPARISON"];
	q71 -> q53 [label="DIFFERENT"];
	q71 -> q54 [label="LESS_THAN"];
	q71 -> q55 [label="MORE_THAN"];
	q71 -> q56 [label="LESS_THAN_EQUALS"];
	q71 -> q57 [label="MORE_THAN_EQUALS"];
	q71 -> q58 [label="PLUS"];
	q71 -> q59 [label="MINUS"];
	q71 -> q60 [label="POWER"];
	q71 -> q61 [label="TIMES"];
	q71 -> q62 [label="SPLIT"];
	q71 -> q63 [label="MOD"];
	q71 -> q64 [label="AND"];
	q71 -> q65 [label="OR"];
	q71 -> q87 [label="','"];
	q71 -> q67 [label="binary_operator"];
	q72 -> q88 [label="')'"];
	q74 -> q52 [label="COMPARISON"];
	q74 -> q53 [label="DIFFERENT"];
	q74 -> q54 [label="LESS_THAN"];
	q74 -> q55 [label="MORE_THAN"];
	q74 -> q56 [label="LESS_THAN_EQUALS"];
	q74 -> q57 [label="MORE_THAN_EQUALS"];
	q74 -> q58 [label="PLUS"];
	q74 -> q59 [label="MINUS"];
	q74 -> q60 [label="POWER"];
	q74 -> q61 [label="TIMES"];
	q74 -> q62 [label="SPLIT"];
	q74 -> q63 [label="MOD"];
	q74 -> q64 [label="AND"];
	q74 -> q65 [label="OR"];
	q74 -> q89 [label="']'"];
	q74 -> q67 [label="binary_operator"];
	q76 -> q52 [label="COMPARISON"];
	q76 -> q53 [label="DIFFERENT"];
	q76 -> q54 [label="LESS_THAN"];
	q76 -> q55 [label="MORE_THAN"];
	q76 -> q56 [label="LESS_THAN_EQUALS"];
	q76 -> q57 [label="MORE_THAN_EQUALS"];
	q76 -> q58 [label="PLUS"];
	q76 -> q59 [label="MINUS"];
	q76 -> q60 [label="POWER"];
	q76 -> q61 [label="TIMES"];
	q76 -> q62 [label="SPLIT"];
	q76 -> q63 [label="MOD"];
	q76 -> q64 [label="AND"];
	q76 -> q65 [label="OR"];
	q76 -> q67 [label="binary_operator"];
	q77 -> q90 [label="MORE_THAN"];
	q78 -> q6 [label="PRIMITIVE"];
	q78 -> q7 [label="ARRAY"];
	q78 -> q91 [label="type"];
	q78 -> q92 [label="params"];
	q78 -> q93 [label="param"];
	q79 -> q52 [label="COMPARISON"];
	q79 -> q53 [label="DIFFERENT"];
	q79 -> q54 [label="LESS_THAN"];
	q79 -> q55 [label="MORE_THAN"];
	q79 -> q56 [label="LESS_THAN_EQUALS"];
	q79 -> q57 [label="MORE_THAN_EQUALS"];
	q79 -> q58 [label="PLUS"];
	q79 -> q59 [label="MINUS"];
	q79 -> q60 [label="POWER"];
	q79 -> q61 [label="TIMES"];
	q79 -> q62 [label="SPLIT"];
	q79 -> q63 [label="MOD"];
	q79 -> q64 [label="AND"];
	q79 -> q65 [label="OR"];
	q79 -> q94 [label="')'"];
	q79 -> q67 [label="binary_operator"];
	q80 -> q34 [label="INCREMENT"];
	q80 -> q35 [label="DECREMENT"];
	q80 -> q39 [label="'='"];
	q83 -> q95 [label="';'"];
	q84 -> q8 [label="INTEGER"];
	q84 -> q9 [label="CARACTERE"];
	q84 -> q10 [label="DOUBLE"];
	q84 -> q11 [label="STRING"];
	q84 -> q16 [label="'{'"];
	q84 -> q46 [label="literal"];
	q84 -> q28 [label="array_literal"];
	q84 -> q96 [label="literais"];
	q86 -> q52 [label="COMPARISON"];
	q86 -> q53 [label="DIFFERENT"];
	q86 -> q54 [label="LESS_THAN"];
	q86 -> q55 [label="MORE_THAN"];
	q86 -> q56 [label="LESS_THAN_EQUALS"];
	q86 -> q57 [label="MORE_THAN_EQUALS"];
	q86 -> q58 [label="PLUS"];
	q86 -> q59 [label="MINUS"];
	q86 -> q60 [label="POWER"];
	q86 -> q61 [label="TIMES"];
	q86 -> q62 [label="SPLIT"];
	q86 -> q63 [label="MOD"];
	q86 -> q64 [label="AND"];
	q86 -> q65 [label="OR"];
	q86 -> q67 [label="binary_operator"];
	q87 -> q44 [label="ID"];
	q87 -> q8 [label="INTEGER"];
	q87 -> q9 [label="CARACTERE"];
	q87 -> q10 [label="DOUBLE"];
	q87 -> q11 [label="STRING"];
	q87 -> q16 [label="'{'"];
	q87 -> q71 [label="expression"];
	q87 -> q23 [label="literal"];
	q87 -> q24 [label="func_call"];
	q87 -> q25 [label="binary_expr"];
	q87 -> q26 [label="access"];
	q87 -> q27 [label="primitive_func"];
	q87 -> q28 [label="array_literal"];
	q87 -> q97 [label="expressions"];
	q91 -> q98 [label="ID"];
	q92 -> q99 [label="')'"];
	q93 -> q100 [label="','"];
	q94 -> q101 [label="'{'"];
	q94 -> q102 [label="block"];
	q95 -> q44 [label="ID"];
	q95 -> q8 [label="INTEGER"];
	q95 -> q9 [label="CARACTERE"];
	q95 -> q10 [label="DOUBLE"];
	q95 -> q11 [label="STRING"];
	q95 -> q16 [label="'{'"];
	q95 -> q103 [label="expression"];
	q95 -> q23 [label="literal"];
	q95 -> q24 [label="func_call"];
	q95 -> q25 [label="binary_expr"];
	q95 -> q26 [label="access"];
	q95 -> q27 [label="primitive_func"];
	q95 -> q28 [label="array_literal"];
	q99 -> q104 [label="':'"];
	q100 -> q6 [label="PRIMITIVE"];
	q100 -> q7 [label="ARRAY"];
	q100 -> q91 [label="type"];
	q100 -> q105 [label="params"];
	q100 -> q93 [label="param"];
	q101 -> q5 [label="ID"];
	q101 -> q6 [label="PRIMITIVE"];
	q101 -> q7 [label="ARRAY"];
	q101 -> q8 [label="INTEGER"];
	q101 -> q9 [label="CARACTERE"];
	q101 -> q10 [label="DOUBLE"];
	q101 -> q11 [label="STRING"];
	q101 -> q12 [label="SUBPROGRAM"];
	q101 -> q13 [label="IF"];
	q101 -> q14 [label="FOR"];
	q101 -> q15 [label="RETURN"];
	q101 -> q16 [label="'{'"];
	q101 -> q17 [label="';'"];
	q101 -> q106 [label="stmts"];
	q101 -> q19 [label="stmt"];
	q101 -> q20 [label="type"];
	q101 -> q21 [label="func_def"];
	q101 -> q22 [label="expression"];
	q101 -> q23 [label="literal"];
	q101 -> q24 [label="func_call"];
	q101 -> q25 [label="binary_expr"];
	q101 -> q26 [label="access"];
	q101 -> q27 [label="primitive_func"];
	q101 -> q28 [label="array_literal"];
	q101 -> q29 [label="if_stmt"];
	q101 -> q30 [label="for_stmt"];
	q101 -> q31 [label="return_stmt"];
	q101 -> q32 [label="atrib"];
	q101 -> q33 [label="declaration"];
	q102 -> q107 [label="ELSE"];
	q103 -> q52 [label="COMPARISON"];
	q103 -> q53 [label="DIFFERENT"];
	q103 -> q54 [label="LESS_THAN"];
	q103 -> q55 [label="MORE_THAN"];
	q103 -> q56 [label="LESS_THAN_EQUALS"];
	q103 -> q57 [label="MORE_THAN_EQUALS"];
	q103 -> q58 [label="PLUS"];
	q103 -> q59 [label="MINUS"];
	q103 -> q60 [label="POWER"];
	q103 -> q61 [label="TIMES"];
	q103 -> q62 [label="SPLIT"];
	q103 -> q63 [label="MOD"];
	q103 -> q64 [label="AND"];
	q103 -> q65 [label="OR"];
	q103 -> q108 [label="';'"];
	q103 -> q67 [label="binary_operator"];
	q104 -> q6 [label="PRIMITIVE"];
	q104 -> q7 [label="ARRAY"];
	q104 -> q109 [label="type"];
	q106 -> q110 [label="'}'"];
	q107 -> q101 [label="'{'"];
	q107 -> q111 [label="block"];
	q108 -> q80 [label="ID"];
	q108 -> q6 [label="PRIMITIVE"];
	q108 -> q7 [label="ARRAY"];
	q108 -> q20 [label="type"];
	q108 -> q81 [label="atrib"];
	q108 -> q82 [label="declaration"];
	q108 -> q112 [label="for_part"];
	q109 -> q101 [label="'{'"];
	q109 -> q113 [label="block"];
	q112 -> q114 [label="')'"];
	q114 -> q101 [label="'{'"];
	q114 -> q115 [label="block"];
}
